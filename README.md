## Explanation:

[JSC.js](https://github.com/mbbill/JSC.js) provides a foundation for embedding JavaScriptCore in the browser using [Emscripten](https://emscripten.org/).

This project aims to modify JavaScriptCore to allow for IPC communication between the main page and the new context and provide a context bridge.

Inspired by [Electron's remote module](https://github.com/electron/remote) and [Embind](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html).

## Use cases:

- Securing code in webpages (custom elements, websocket protocols, HTML generation, network requests, etc..)
- Skipping parse times for huge blocks of code via bytecode
- Simulating enviorments such as NodeJS by having no `window` or `location` properties in the context

### Current progress:

- Bridging âœ…

- Loading bytecode âœ…

- Upgrading JavaScriptCore to the latest (for WeakRefs) ðŸš«

#### Garbage collection:

- Storing references as WeakRefs ðŸš«

## Usage:

â„¹ This project is in its early stages. If a feature is missing, open an issue or implement it yourself and create a pull request.

Embed the demo code on your website or host it locally

```html
<script src='https://e9x.github.io/jsc.js-bridge/dist/jsc.min.js?6.27.2021'></script>
```

### Demos:

[Compiler](./compiler)

[Secure Input Element](./secure-input)



### Calling native functions:

Native functions cannot accept handles. Create a native object and assign your data to it.

```js
JSC.eval(() => {
	var native_object = new JSC.context.Object();
	var observer = new JSC.context.MutationObserver(mutations => {
		console.log('MUTATIONS:', mutations);
	});
	
	native_object.subtree = true;
	native_object.childList = true;
	
	// If we used a object created in this context, we will get:
	// Failed to execute 'observe' on 'MutationObserver': The provided value cannot be converted to a sequence.
	
	observer.observe(JSC.context.document, native_object);
});
```

### JSC.context

A handle referencing the context's `globalThis`.

### JSC.global

A handle referencing the context's `JSC` object.

### JSC.eval(code, [...args]) â‡’ `Handle`

Returns a handle to the code executed in the parallel context as a handle or JSON.

| Param | Type | Description |
| --- | --- | --- |
| code | `String|Function` | A string or function containing code to be executed in the JSC context |
| ...args | `Any` | Arguments to call `code` with, this will be ignored if `code` is a string |

#### Example:

```js
console.log(JSC.eval(`globalThis.toString()`)); // "[object GlobalObject]"

JSC.eval(function(exposed_arg){
  console.log(typeof fetch); // undefined
  console.log(typeof exposed_arg); // function
  
  exposed_arg('https://www.google.com').then(res => console.log(res.headers.get('content-type')));
}, fetch);
```

### JSC.bytecode.compile(code) â‡’ `String`

Returns a hex encoded string containing the bytecode result.

| Param | Type | Description |
| --- | --- | --- |
| code | `String` | Input for generating bytecode |

### JSC.bytecode.load(bytecode)

Loads and executes bytecode generated by `JSC.bytecode.compile`.

Things to note:

- Calling `.toString()` on a function created in compiled bytecode will only return the function name because:

- All source code and syntax is removed in compiled code (including function bodies).

- The returned value cannot be accessed. You will have to expose a function or data in the `JSC.global` object or in the context.

| Param | Type | Description |
| --- | --- | --- |
| bytecode | `String` | Hex encoded bytecode |

#### Example:

```js
// Do not include the compiled function outside of development.
// If this weren't the documentation then it would look like:
// var BYTECODE = "00000000FFFFFF7F38000000000000.....";

var BYTECODE = JSC.bytecode.compile(() => {
	// Taken from https://github.com/darkskyapp/string-hash/blob/master/index.js
	function hash(str){
		var hash = 5381, i = str.length;

		while(i)hash = (hash * 33) ^ str.charCodeAt(--i);
		
		return hash >>> 0;
	}
	
	JSC.global.private_function = hash;
});

// Load the bytecode
JSC.bytecode.load(BYTECODE);

console.log(JSC.global.private_function.toString()); // "function hash"

// Calling toString on the function generated from bytecode no longer returns the source which means our hash function is secure.
```

### JSC.debugger()

Runs a debugger statement on the parallel context (preferrably main context, debugging JSC contexts will fail)

#### Example:

```js
// Enter the JSC context
JSC.eval(() => {
	// Create an instance of the parent context's headers because they are not present in this context.
	var headers = new JSC.context.Headers();
	
	// Create a native object for calling the native function fetch.
	var options = new JSC.context.Object();
	
	options.method = 'POST';
	options.body = JSON.stringify({
		'sent-from': 'jsc',
	});
	
	options.headers = headers;
	headers.set('content-type', 'application/json');
	
	// Call the parent context's native fetch function using our native object.
	JSC.context.fetch('https://api.sys32.dev/v2/test', options).then(res => {
		console.log('Recieved response code:', res.status);
		// [SUB] Recieved response code: 404
	});
});
```

## Building:

Original build instructions found at https://github.com/mbbill/JSC.js/blob/master/README.md

### Build the WASM:

1. Install [Emscripten](https://emscripten.org/docs/getting_started/downloads.html#installation-instructions-using-the-emsdk-recommended) and setup em++ enviorment variables

2. Install [Ninja/CMake](https://cmake.org/download/)

3. Open a terminal

4. Clone the repo:
```sh
git clone https://github.com/e9x/jsc.js-bridge.git
```

5. Enter the wasm builder:
```sh
cd jsc.js-bridge/build-wasm
```

6. Run `prep_env.bat`:
```sh
./prep_env.bat
```

7. Create the build target:
```sh
gn gen out --args="target_os=\"wasm\""
```

8. Build with Ninja:
```sh
ninja -C out
```

### Build the JS:

1. Install [NodeJS 14<=](https://nodejs.org/en/)

2. Clone the repo or enter pre-existing folder:
```
git clone https://github.com/e9x/jsc.js-bridge.git
```

3. Enter the JS builder directory:
```sh
cd jsc.js-bridge/build-wasm
```

4. Install NPM modules:
```sh
npm install
```

5. Run the builder:
```sh
node ./index.js --once
```

JS output is found in the `dist/` folder
