## Calling native functions

Native functions cannot accept handles. Create a native object and assign your data to it.

```js
var context = new JSC.Context();

context.execute(() => {
	var native_object = new JSC.context.bridge.Object();
	var observer = new JSC.context.bridge.MutationObserver(mutations => {
		console.log('MUTATIONS:', mutations);
	});
	
	native_object.subtree = true;
	native_object.childList = true;
	
	// If we used a object created in this context, we will get:
	// Failed to execute 'observe' on 'MutationObserver': The provided value cannot be converted to a sequence.
	
	observer.observe(JSC.context.bridge.document, native_object);
});
```

## JSC.context

An instance of JSC.Context only found in the client.

## new JSC.Context();

Creates a JSC context.

### Example

```js
var context = new JSC.Context();

context.execute('console.log("test");');

context.destroy();
```

### Context.on('log', callback)
### Context.on('info', callback)
### Context.on('warn', callback)
### Context.on('error', callback)
### Context.on('trace', callback)

Handler for context's console, default behavior is to log to the parent context.

#### Example

```js
var context = new JSC.Context();

context.on('log', (...data) => console.log('Context says:', ...data));
```

### Context.bridge

A handle referencing the context's `globalThis`.

### Context.global

A handle referencing the context's representation of the context.

### Context.destroy()

Deallocates JSC context and references.

### Context.execute(code, [...args]) ⇒ `Handle`

Returns a handle to the code executed in the parallel context as a handle or JSON.

| Param   | Type              | Description                                                            |
| ------- | ----------------- | ---------------------------------------------------------------------- |
| code    | `String|Function` | A string or function containing code to be executed in the JSC context |
| ...args | `Any` | Arguments to call `code` with, this will be ignored if `code` is a string          |

#### Example

```js
console.log(context.execute(`globalThis.toString()`)); // "[object GlobalObject]"

context.execute(function(exposed_arg){
  console.log(typeof fetch); // undefined
  console.log(typeof exposed_arg); // function
  
  exposed_arg('https://www.google.com').then(res => console.log(res.headers.get('content-type')));
}, fetch);
```

### Context.bytecode.compile(code) ⇒ `Uint8Array`

Returns a Uint8Array containing the bytecode.

| Param | Type | Description |
| --- | --- | --- |
| code | `String` | Code to compile |

### JSC.bytecode.execute(bytecode)

Loads and executes bytecode generated by `JSC.bytecode.compile`.

Things to note:

- Calling `.toString()` on a function created in compiled bytecode will only return the function name because:

- All source code and syntax is removed in compiled code (including function bodies).

- The returned value cannot be accessed. You will have to expose a function or data in the `JSC.global` object or in the context.

| Param | Type | Description |
| --- | --- | --- |
| bytecode | `Array|Uint8Array|ArrayBuffer` | Bytecode |

#### Example

```js
// Do not include the compiled function outside of development.
// If this weren't the documentation then it would look like:
// var BYTECODE = [0, 0, 0, 0, 255, 255, 255, 127, 56, 0, 0, 0, 0, 0, 0, ];

var context = new JSC.Context();

var BYTECODE = context.bytecode.compile(() => {
	// Taken from https://github.com/darkskyapp/string-hash/blob/master/index.js
	function hash(str){
		var hash = 5381, i = str.length;

		while(i)hash = (hash * 33) ^ str.charCodeAt(--i);
		
		return hash >>> 0;
	}
	
	JSC.context.global.private_function = hash;
});

// Load the bytecode
context.bytecode.execute(BYTECODE);

console.log(context.private_function.toString()); // "function hash"

// Calling toString on the function generated from bytecode no longer returns the source which means our hash function is secure.
```

### Context.debugger()

Runs a debugger statement on the parallel context (preferrably main context, debugging JSC contexts will fail)

#### Example

```js
var context = new JSC.Context();

// Enter the JSC context
context.execute(() => {
	// Create an instance of the parent context's headers because they are not present in this context.
	var headers = new JSC.context.bridge.Headers();
	
	// Create a native object for calling the native function fetch.
	var options = new JSC.context.bridge.Object();
	
	options.method = 'POST';
	options.body = JSON.stringify({
		'sent-from': 'jsc',
	});
	
	options.headers = headers;
	headers.set('content-type', 'application/json');
	
	// Call the parent context's native fetch function using our native object.
	JSC.context.bridge.fetch('https://api.sys32.dev/v2/test', options).then(res => {
		console.log('Recieved response code:', res.status);
		// [SUB] Recieved response code: 404
	});
});
```