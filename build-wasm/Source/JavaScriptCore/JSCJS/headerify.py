#!/usr/bin/env python
# billming
# The script is similar to xxd, but I don't want to add one more dependency, and xxd doesn't produce alignas and const modifiers.
# alignas sometimes are critical to some data files, like icu data needs to be 4-byte aligned.

import argparse
import os
import sys

parser = argparse.ArgumentParser()
parser.add_argument("file", help="file or folder to process", type=str)
parser.add_argument("out", help="output file name", type=str)
args = parser.parse_args()

# if the input is a folder, process all files under it.
if os.path.isdir(args.file):
    filesToProcess = [os.path.join(args.file, f) for f in os.listdir(args.file) if os.path.isfile(os.path.join(args.file, f))]
    if len(filesToProcess) == 0:
        sys.stderr.write("Error: " + args.file + " is empty")
        exit(-1)
elif os.path.isfile(args.file):
    filesToProcess = [args.file]
else:
    sys.stderr.write("Error: " + args.file + " does not exist!")
    exit(-1)

outFile = args.out
if os.path.isfile(args.out):
    sys.stderr.write("Warning: \"" + outFile + "\" exists and will be overwritten!")

out = open(outFile, 'wb')
out.write("// billming\n")
out.write("// DO NOT MODIFY! Generated by headerify.py\n\n")
out.write("#pragma once\n\n")

def normalize(text):
    for ch in ['\\','`','*','{','}','[',']','(',')','>','#','+','-','.','!','$','\'']:
        text = text.replace(ch,"_")
    return text

for fileName in filesToProcess:
    f = open(fileName, 'rb')
    data = f.read() # it's fine to read everything into memory since we're not like converting huge binary file into headers.
    name = normalize(os.path.basename(fileName))
    out.write("alignas(8) const unsigned int {}_len = {};\n".format(name, len(data) + 1))
    out.write("alignas(8) const char {}[] = {{\n".format(name))
    outStr = []
    for b in data:
        outStr.append("0x{0:02x},".format(ord(b)))
    outStr.append("0x00")
    out.write("".join(outStr))
    out.write("\n};\n\n")
